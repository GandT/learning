#include <stdio.h>#include <iostream>using namespace std;#define hfor(X)		for(int h = 0;h < (X);++h)#define ifor(X)		for(int i = 0;i < (X);++i)#define ifor1(X)		for(int i = 1;i <= (X);++i)#define jfor1(X)		for(int j = 1;j <= (X);++j)#define kfor1(X)		for(int k = 1;k <= (X);++k)int vertices;			//頂点数bool matrix[101][101];	//隣接行列short mytime;				//時間short d[101];			//d[n]を最初に発見した時間short f[101];			//f[n]に戻ってきた時間/*****深さ優先探索*****/void dfs(int cur){	//訪問時刻の記録	++mytime;	d[cur] = mytime;		//再帰的に次の場所に訪問	ifor1(vertices){		//つながっている行ったことのない場所に行く		if(matrix[cur][i] && d[i] == 0)dfs(i);	}		//戻ってきた時刻を記録	++mytime;	f[cur] = mytime;		//終了（戻る）	return;}/*****main関数*****/int main(){	//頂点数を受け取る	cin >> vertices;		//頂点数だけリストから行列への変換処理を行う	hfor(vertices){				//操作するエッジ番号を受け取る		int fromedge;		cin >> fromedge;				//つながるエッジの数を受け取る		int edges;		cin >> edges;				//edgeの数だけループしてつながる先を受け取る		ifor(edges){			//つながる先を受け取る			int toedge;			cin >> toedge;						//行列を操作			matrix[fromedge][toedge] = true;		}	}		//深さ優先探索	int start = 1;	int oldstart = 1;	while(start){		//探索を行う		dfs(start);				//現在のstart値を記録		oldstart = start;				//ほかに孤立ブロックがないか判定		ifor1(vertices){						//d[i]が0なら未探査ポイントなのでループを続ける			if(d[i] == 0){				//開始地点をiに設定				start = i;				break;			}		}				//start値が変わっていなければ終了		if(start == oldstart)break;	}		//出力	ifor1(vertices){		cout << i << " " << d[i] << " " << f[i] << endl;	}}
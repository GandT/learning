#include <stdio.h>#include <iostream>using namespace std;#define efor(X)		for(int i = 0;i < X;++i)#define efor2(X)	for(int ii = 0;ii < X;++ii)int node;				//頂点の数int nodeA,nodeB;		//共通祖先の解析対象int parent[10010];		//配列番号の親が変数として中に入っている。-1なら親なしint pipeline1[10010];int pipeline2[10010];int result;int main(){	//ループ回数の設定	int roop;	cin >> roop;		//指定回数分ループ	for(int t = 0;t < roop;++t){				//初期化処理		efor(10010){			parent[i] = -1;			pipeline1[i] = pipeline2[i] = -1;		}		//頂点の数を受け取る		cin >> node;				//treeをつなげる		efor(node - 1){						//親と子のセットを受け取る			int p,c;					//parent child			cin >> p >> c;						//parent[c]の値をpに設定			parent[c] = p;		}					//共通祖先の解析対象を受け取る		cin >> nodeA >> nodeB;					/*****共通祖先の解析*****/		//nodeAからルートへの道を第一パイプラインにセット		efor(10010){			//パイプラインに記録を残す			pipeline1[i] = nodeA;						//親がいなければ終了			if(parent[nodeA] == -1)break;						//遡上			nodeA = parent[nodeA];		}		efor(10010){			//パイプラインに記録を残す			pipeline2[i] = nodeB;						//親がいなければ終了			if(parent[nodeB] == -1)break;						//遡上			nodeB = parent[nodeB];		}				//A側を固定しB側の親と同じ地点を探す		efor(10010){			efor2(10010){				if(pipeline1[i] == pipeline2[ii]){result = pipeline1[i]; goto ending;}				else if(pipeline2[ii] == -1)break;			}		}				ending:				//結果を出力		printf("%d\n",result);	}}
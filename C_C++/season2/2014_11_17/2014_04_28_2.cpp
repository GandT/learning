#include <stdio.h>#include <iostream>using namespace std;#define hfor(X)			for(int h = 0;h < X;++h)#define ifor(X)			for(int i = 0;i < X;++i)#define jfor(X)			for(int j = 0;j < X;++j)#define kfor(X)			for(int k = 0;k < X;++k) int dsnum;				//データセット数short gx,gy;			//目標地点の座標short mat;				//マタタビの数float mx[101],my[101];	//マタタビの座標int heian[16][16];		//平安座標（x、y）におけるルート数int main(void){	//データセット数を受け取る	cin >> dsnum;		//データの数だけループ（メインループ）	hfor(dsnum){			//配列の初期化		ifor(16)jfor(16)heian[i][j] = 0;		heian[0][0] = 1;		ifor(101)mx[i] = my[i] = 0;				//目標地点の座標を受け取る		cin >> gx;		cin >> gy;				//マタタビの数を受け取る		cin >> mat;				//マタタビの座標を確定		ifor(mat){						//挟み込み座標の代入用変数			short mx1,my1,mx2,my2;						//両端座標を受け取る			cin >> mx1 >> my1 >> mx2 >> my2;						//マタタビ座標の設定			mx[i] = (mx1 + mx2) * 0.5;			my[i] = (my1 + my2) * 0.5;					}				//マタタビ座標に基づきルート数を計算		ifor(16){		//iがy座標		jfor(16){		//jがx座標						//上や左にマタタビがあるかどうかのフラグ			bool umf = false;			bool lmf = false;						//i（y）が0かどうか			if(i == 0)umf = true;						//j（x）が0かどうか			if(j == 0)lmf = true;						//マタタビチェック			kfor(mat){				if(mx[k] == j - 0.5 && my[k] == i){lmf = true; /*cout << "⬅";*/}				if(my[k] == i - 0.5 && mx[k] == j){umf = true; /*cout << "⬆";*/}			}						//マタタビに応じてパターンを算出			if(!lmf)heian[j][i] += heian[j - 1][i];			if(!umf)heian[j][i] += heian[j][i - 1];						//printf("heian[%d][%d]：",i,j);			//cout << heian[j][i] << " ";			//if(j == 15)cout << endl;						//フラグの初期化			umf = lmf = false;		}		}								//道の数を出力		if(heian[gx][gy] == 0)puts("Miserable Hokusai!");		else cout << heian[gx][gy] <<endl;	}}
load("00_simplesort.rb")
load("00_mergesort.rb")
load("pg10.rb")

#配列を受け取る
a = pg10()

#####5000要素だけ用いて配列をソート#####
#単純ソート
puts "simplesort開始"
simplesort(a[0..5000])

#併合ソート
puts "mergesort開始"
mergesort(a[0..5000])



##########ここからコメント##########
=begin

	　simplesortは5000要素でもかなり時間がかかるように感じるが、mergesortの場合は一瞬で計算が終了した。mergesortのみ要素数をさらに10万にまで
	増やして再計測を行ったが体感的な処理時間はあまり変わらなかった。この差を計算量の観点から考察する。
	　まず、simplesortは関数simplesortでfor文が呼び出されており、その中で呼び出されている関数min_indexにも更にfor文が存在することから、計算量
	のオーダーはO(n^2)である。今回のn=5000の状況下では、O(25000000)となる。
	　これに対して、mergesortは配列の要素数にlog2をとった回数だけwhileループがまわされ、要素数に比例してmerge関数での大小比較が発生するので、
	計算量のオーダーはO(nlog(n))である。今回のn==5000ではO(5000*12~3)でO(62000)程度となる。これはsimplesortと比べ、10進数で3桁小さく、故に計
	算がsimplesortと比べ格段に早く終わったのだと考えられる。
	
	
	　なお、今回のソートでは文字型の数値を使ってソートしている（と考えられる）ため、本来の辞書順とは異なり大文字が全て辞書順に並んだ後小文字が
	辞書順に並び直されるという形になっているが、ソート速度の比較という今回の目的に対しては影響がないため手を加えずそのままとした。

=end
##########ここまでコメント##########
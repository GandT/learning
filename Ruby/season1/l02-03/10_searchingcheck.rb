load("00_mergesort.rb")


#仮説1から4の成立回数を記録するカウンター
$true1 = 0;
$true2 = 0;
$true3 = 0;
$true4 = 0;

#検証用find関数
def find(t,s) # sがtの何番目かを探す
    i = 0 # 下限
    j = t.length-1 # 上限
    while i<=j # 間があいていたら、
        k = (i+j)/2 # 中間をとり
        if t[k]==s # sと一致したら
            return k # その添字を返す
            else
            if t[k] < s # 中間より大きければ、
                i = k+1 # 下限を引き上げ、
                else # 中間より小さければ
                j = k-1 # 上限を引き下げる。
            end
        end
    end
    
    #####検証#####
    if j == i-1 then
        $true1 += 1;
    end
    if k == i then
        $true2 += 1;
    end
    if k == j then
        $true3 += 1;
    end
    if i < 0 || i >= t.length || j < 0 || j >= t.length then
        $true4 += 1;
    end
    #############
    
    return nil # 見つからない
end

#1000回試行する
for roop in 1..1000
	#配列を用意
	a = [];

	#配列の中身を入れる
    for i in 0..2000
        a << rand() * 10000;
    end
	
    #配列をソート
    a = mergesort(a);
    
    #発見対象の数字の設定
    num = rand() * 10000;
    
    #検証用関数を呼び出す
    check = find(a,num);
    
    #もし見つかってしまっていた場合は結果を破棄
    if check then
        roop -= 1;
    end
end

#結果を表示
puts  "【結果】";
print("仮説1：",($true1),"回\n");
print("仮説2：",($true2),"回\n");
print("仮説3：",($true3),"回\n");
print("仮説4：",($true4),"回\n");


=begin
【仮説一覧】
(1) j == i-1である。
(2) k == iである。	
(3) k == jである。	
(4) iやjが配列の範囲外となることがある。

【結果】
仮説1：1000回
仮説2：515回
仮説3：485回
仮説4：3回


【解釈】
　仮説1,2,3については、「〜〜である」という形なので、必ず成り立つ場合のみ真であるということになる。この場合、1000回実
行して1000回成り立っている仮説1のみが真である可能性が非常に高い。
　一方、仮説4は「〜〜となることがある」という形であるため、成り立った回数が0回でなければ真ということになる。この場合は
3回と非常に少ないものの、成り立つことがあるということが示されたため、仮説4は真であるといえる。

=end
load("00_mergesort.rb")
load("00_search.rb")
load("pg10.rb")

#配列を受け取る
a = pg10()

puts("読み込み完了")

#ソート
b = mergesort(a)

puts("sort完了")

#線形探索
puts("[you]線形探索開始")
#####10回検索開始#####
for i in 1..10 do
	print lsearch(b,"you")
	print "\n"
end
#####10回検索終了#####
puts("[you]線形探索完了")

#二分探索
puts("[you]二分探索開始")
#####10回検索開始#####
for i in 1..10 do
	print bsearch(b,"you")
	print "\n"
end
#####10回検索終了#####
puts("[you]二分探索完了")

#線形探索
puts("[an]線形探索開始")
#####100回検索開始#####
for i in 1..100 do
	print lsearch(b,"an")
	print "\n"
end
#####100回検索終了#####
puts("[an]線形探索完了")

#二分探索
puts("[an]二分探索開始")
#####100回検索開始#####
for i in 1..100 do
	print bsearch(b,"an")
	print "\n"
end
#####100回検索終了#####
puts("[an]二分探索完了")



##########ここからコメント##########
=begin

	　配列全体の要素数をnとしたときに、線形探索の計算量はO(n)（係数をつけるならn/2）で二分探索の計算量はO(logn)である。実際にこのプログラムを
	実行してみたところ、線形探索では一回一回の実行にある程度の時間がかかるものの、二分探索ではその十倍量および百倍量の実行もともに一瞬で終わ
	らせてしまった。（これ以上の回数の実行はprint文の実行によるリソース消費が問題となってきてしまうため検証していない。）この実行速度の違いは
	上記の計算量の違いを如実に表しているものであるといえる。（C言語におけるclock関数のようなものがあればより正確に実行速度を計測できたと考え
	られる。）
	　実行速度全体としては上記のような傾向が読み取れたが、単語による違いは主に線形探索にのみ観測された。辞書順に並べたときに最後の方にくると
	考えられる[you]と、最初の方にくると考えられる[an]の二つでそれぞれ探索を行ったところ、線形探索ではyouよりもanの方が十倍とはいわないまでも
	かなり早く探索することができた。これは「前から順番に探す」という線形探索のアルゴリズムに起因するものであると考えられる。理論上、何度も
	「割り続ける」二分探索においては中心から同程度には慣れていると考えられるこれら二つの単語に対する探索速度はさほど変わらないと考えられるも
	のの、それぞれの処理速度が速すぎたために今回は違いを計測することはできなかった。
	
	　ただし、まず最初にデータの読み込み、次にソートの方がこれら探索よりも一回にかかる時間は長い。また、線形探索と二分探索で異なった探索の結
	果が帰ってくるが、これは複数ある同じ単語のうち線形探索ではその先頭のもの、二分探索ではそうではないものを見つけたことによるものであり、バ
	グではないと考えられる。

=end
##########ここまでコメント##########